\documentclass[11pt,letterpaper,titlepage]{article}

% AMS packages.
%\usepackage{amsmath}
%\usepackage{amsthm}
%\usepackage{amsfonts}
%\usepackage{mathtools}
%\usepackage{amssymb}

\title{Verifying Burrows Wheeler Transformation In Coq}
\author{Hanlin He, Sourav Dasgupta, Paul Perrot, Alan Padilla Chua}

\begin{document}

\maketitle

\section{Motivation}

The idea that spawned this research project was given by Dr. Kevin Hamlen. When
verifying security implementations, compression algorithms seemed to be
overlooked. This left a security gap that is to be trusted without any formal
verification. Our initial goal was to verify a full compression algorithm from
top to bottom. However, we narrowed our search to \emph{bzip2}'s compression
stack and saw that its core algorithm depended on the Burrows Wheeler
Transformation\cite{}.

BWT (Burrows Wheeler Transformation), has some important security properties
related to integrity. It holds that BWT is a reversible transformation that has
no side effects on the data. We saw BWT to be of great potential to be verified
in Coq. Its full verification could narrow trusted code base of \emph{bzip2}'s
compression and allow future teams to tackle the full verification of
\emph{bzip2}.

\section{Preliminaries}

Our Coq implementation has been tested on the CoqIDE version 8.6.1 for Windows,
Mac, and Linux.

\section{Project Summary}

\subsection{Approach}

For our implementation of BWT in Coq we decided to prove that the
transformation is lossless; Meaning that for any string we apply the forward
BWT on, we can subsequently perform the inverse BWT on that result and get the
original string back. In order to accomplish this and be able to reason about
it, we implemented the forward BWT and inverse BWT in Coq. Before getting to
these two implementations we need to discuss some more general, but still
important, parts of our implementation.

Dr. Kevin Hamlen mentioned that proving theorems about lists could lead to
complex issues. So instead of using lists, for our main implementation we chose
to implement strings as mappings ($str: nat \rightarrow option\ nat$) and
matrices as a mapping of mappings ($matrix: nat \rightarrow str$). It is worth
noting that we did create a generic implementation of BWT using lists but did
not attempt to prove any lemmas about it. Our proofs are solely related to the
string mapping version of our Coq code.

\subsubsection{Forward BWT}

Given a string $S$ as input, we first convert a string into a $str$ mapping
$s$, and construct the matrix by right shift $s$ , then assuming a given $sort$
function that sort the matrix lexicographically, and return the last column of
the sorted matrix as the result string.

\subsubsection{Inverse BWT}

Given a string $L$ and an index $i$ as input, we assume a given $sort$ function
that sort $L$ lexicographically, we first generate the index mapping $\pi_L$
between the original string and the sorted string, and then recursively
generates a sequence of indices as $\pi_L^k(i)$, each of which corresponds to
$k$-th character in the original string, and apply all the index with the given
string $L$ to regenerate the original before BWT.

\subsection{Difficulties}

\subsubsection{Sorting}

The BWT algorithm requires two stable lexicographical sorts: matrix sort and
string sort. Our main implementation of strings and matrices uses an abstract
mapping of the strings rather than lists. This prohibited us from importing a
Coq sorting library because it was unclear how our abstract mapping could use a
sorting library meant for lists. To overcome this, we decided that instead of
proving a sorting algorithm ourselves, we would assume either a sorting
algorithm that satisfies a set of properties for our abstract mapping is given,
or the sorted version of the string or matrix mapping is given.

Another problem following this path is how to introduce sort as our
assumption.

\end{document}

